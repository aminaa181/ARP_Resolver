library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity ARP_Resolver is
    Port (
        -- Clock and Reset
        clock       : in  STD_LOGIC;
        reset       : in  STD_LOGIC;
        
        -- Control Inputs
        resolve     : in  STD_LOGIC;
        ip_address  : in  STD_LOGIC_VECTOR(31 downto 0);
        
        -- Status Outputs
        done        : out STD_LOGIC;
        mac_address : out STD_LOGIC_VECTOR(47 downto 0);
        busy        : out STD_LOGIC;
        
        -- Input Stream (ARP Reply)
        in_data     : in  STD_LOGIC_VECTOR(7 downto 0);
        in_valid    : in  STD_LOGIC;
        in_sop      : in  STD_LOGIC;
        in_eop      : in  STD_LOGIC;
        in_ready    : out STD_LOGIC;
        
        -- Output Stream (ARP Request)
        out_data    : out STD_LOGIC_VECTOR(7 downto 0);
        out_valid   : out STD_LOGIC;
        out_sop     : out STD_LOGIC;
        out_eop     : out STD_LOGIC;
        out_ready   : in  STD_LOGIC
    );
end ARP_Resolver;

architecture Behavioral of ARP_Resolver is
    
    -- FSM States
    type state_type is (IDLE, ARP_REQUEST, WAITING_FOR_REPLY, RECEIVING_REPLY, DONE_STATE, IGNORE);
    signal current_state, next_state : state_type;
    
    -- Internal signals
    signal byte_counter : unsigned(7 downto 0);
    signal error : STD_LOGIC;
    signal stored_ip : STD_LOGIC_VECTOR(31 downto 0);
    signal received_mac : STD_LOGIC_VECTOR(47 downto 0);
    signal sender_mac : STD_LOGIC_VECTOR(47 downto 0) := x"001A2B3C4D5E"; -- Example MAC
    
    -- ARP packet constants
    constant ARP_PACKET_SIZE : integer := 42;
    constant BROADCAST_MAC : STD_LOGIC_VECTOR(47 downto 0) := x"FFFFFFFFFFFF";
    constant ETHERTYPE_ARP : STD_LOGIC_VECTOR(15 downto 0) := x"0806";
    constant ARP_HTYPE : STD_LOGIC_VECTOR(15 downto 0) := x"0001";
    constant ARP_PTYPE : STD_LOGIC_VECTOR(15 downto 0) := x"0800";
    constant ARP_HLEN : STD_LOGIC_VECTOR(7 downto 0) := x"06";
    constant ARP_PLEN : STD_LOGIC_VECTOR(7 downto 0) := x"04";
    constant ARP_OPER_REQUEST : STD_LOGIC_VECTOR(15 downto 0) := x"0001";
    constant ARP_OPER_REPLY : STD_LOGIC_VECTOR(15 downto 0) := x"0002";
    
begin

    -- State Register Process
    process(clock, reset)
    begin
        if reset = '1' then
            current_state <= IDLE;
        elsif rising_edge(clock) then
            current_state <= next_state;
        end if;
    end process;
    
    -- Next State Logic and Output Logic
    process(current_state, resolve, byte_counter, in_valid, in_sop, in_eop, error, out_ready)
    begin
        -- Default values
        next_state <= current_state;
        
        case current_state is
            when IDLE =>
                if resolve = '1' then
                    next_state <= ARP_REQUEST;
                end if;
                
            when ARP_REQUEST =>
                if byte_counter = ARP_PACKET_SIZE - 1 and out_ready = '1' then
                    next_state <= WAITING_FOR_REPLY;
                end if;
                
            when WAITING_FOR_REPLY =>
                if in_valid = '1' and in_sop = '1' then
                    next_state <= RECEIVING_REPLY;
                end if;
                
            when RECEIVING_REPLY =>
                if error = '1' then
                    next_state <= IGNORE;
                elsif in_eop = '1' and in_valid = '1' then
                    next_state <= DONE_STATE;
                end if;
                
            when DONE_STATE =>
                next_state <= IDLE;
                
            when IGNORE =>
                if in_eop = '1' and in_valid = '1' then
                    next_state <= IDLE;
                end if;
                
            when others =>
                next_state <= IDLE;
        end case;
    end process;
    
    -- Byte Counter Process
    process(clock, reset)
    begin
        if reset = '1' then
            byte_counter <= (others => '0');
        elsif rising_edge(clock) then
            case current_state is
                when IDLE =>
                    byte_counter <= (others => '0');
                    
                when ARP_REQUEST =>
                    if out_ready = '1' then
                        if byte_counter < ARP_PACKET_SIZE - 1 then
                            byte_counter <= byte_counter + 1;
                        end if;
                    end if;
                    
                when RECEIVING_REPLY | IGNORE =>
                    if in_valid = '1' then
                        if byte_counter < ARP_PACKET_SIZE - 1 then
                            byte_counter <= byte_counter + 1;
                        else
                            byte_counter <= (others => '0');
                        end if;
                    end if;
                    
                when WAITING_FOR_REPLY =>
                    byte_counter <= (others => '0');
                    
                when others =>
                    byte_counter <= (others => '0');
            end case;
        end if;
    end process;
    
    -- Store IP Address on resolve
    process(clock, reset)
    begin
        if reset = '1' then
            stored_ip <= (others => '0');
        elsif rising_edge(clock) then
            if resolve = '1' and current_state = IDLE then
                stored_ip <= ip_address;
            end if;
        end if;
    end process;
    
    -- Output Data Generation for ARP Request
    process(clock, reset)
    begin
        if reset = '1' then
            out_data <= (others => '0');
        elsif rising_edge(clock) then
            if current_state = ARP_REQUEST and out_ready = '1' then
                case to_integer(byte_counter) is
                    -- Ethernet Header: Destination MAC (Broadcast)
                    when 0 to 5 => out_data <= x"FF";
                    
                    -- Ethernet Header: Source MAC
                    when 6  => out_data <= sender_mac(47 downto 40);
                    when 7  => out_data <= sender_mac(39 downto 32);
                    when 8  => out_data <= sender_mac(31 downto 24);
                    when 9  => out_data <= sender_mac(23 downto 16);
                    when 10 => out_data <= sender_mac(15 downto 8);
                    when 11 => out_data <= sender_mac(7 downto 0);
                    
                    -- EtherType: ARP
                    when 12 => out_data <= ETHERTYPE_ARP(15 downto 8);
                    when 13 => out_data <= ETHERTYPE_ARP(7 downto 0);
                    
                    -- ARP Header: HTYPE (Ethernet)
                    when 14 => out_data <= ARP_HTYPE(15 downto 8);
                    when 15 => out_data <= ARP_HTYPE(7 downto 0);
                    
                    -- ARP Header: PTYPE (IPv4)
                    when 16 => out_data <= ARP_PTYPE(15 downto 8);
                    when 17 => out_data <= ARP_PTYPE(7 downto 0);
                    
                    -- ARP Header: HLEN (6)
                    when 18 => out_data <= ARP_HLEN;
                    
                    -- ARP Header: PLEN (4)
                    when 19 => out_data <= ARP_PLEN;
                    
                    -- ARP Header: OPER (Request)
                    when 20 => out_data <= ARP_OPER_REQUEST(15 downto 8);
                    when 21 => out_data <= ARP_OPER_REQUEST(7 downto 0);
                    
                    -- Sender MAC Address
                    when 22 => out_data <= sender_mac(47 downto 40);
                    when 23 => out_data <= sender_mac(39 downto 32);
                    when 24 => out_data <= sender_mac(31 downto 24);
                    when 25 => out_data <= sender_mac(23 downto 16);
                    when 26 => out_data <= sender_mac(15 downto 8);
                    when 27 => out_data <= sender_mac(7 downto 0);
                    
                    -- Sender IP Address
                    when 28 => out_data <= stored_ip(31 downto 24);
                    when 29 => out_data <= stored_ip(23 downto 16);
                    when 30 => out_data <= stored_ip(15 downto 8);
                    when 31 => out_data <= stored_ip(7 downto 0);
                    
                    -- Target MAC Address (zeros)
                    when 32 to 37 => out_data <= x"00";
                    
                    -- Target IP Address
                    when 38 => out_data <= stored_ip(31 downto 24);
                    when 39 => out_data <= stored_ip(23 downto 16);
                    when 40 => out_data <= stored_ip(15 downto 8);
                    when 41 => out_data <= stored_ip(7 downto 0);
                    
                    when others => out_data <= x"00";
                end case;
            end if;
        end if;
    end process;
    
    -- Receive and Validate ARP Reply
    process(clock, reset)
    begin
        if reset = '1' then
            received_mac <= (others => '0');
            error <= '0';
        elsif rising_edge(clock) then
            if current_state = WAITING_FOR_REPLY then
                error <= '0';
                received_mac <= (others => '0');
            elsif current_state = RECEIVING_REPLY and in_valid = '1' then
                -- Check ARP operation type at bytes 20-21 (should be 0x0002 for reply)
                if byte_counter = 20 and in_data /= x"00" then
                    error <= '1';
                elsif byte_counter = 21 and in_data /= x"02" then
                    error <= '1';
                end if;
                
                -- Extract sender MAC address (bytes 22-27)
                case to_integer(byte_counter) is
                    when 22 => received_mac(47 downto 40) <= in_data;
                    when 23 => received_mac(39 downto 32) <= in_data;
                    when 24 => received_mac(31 downto 24) <= in_data;
                    when 25 => received_mac(23 downto 16) <= in_data;
                    when 26 => received_mac(15 downto 8)  <= in_data;
                    when 27 => received_mac(7 downto 0)   <= in_data;
                    when others => null;
                end case;
                
                -- Verify sender IP matches our target IP (bytes 28-31)
                case to_integer(byte_counter) is
                    when 28 => if in_data /= stored_ip(31 downto 24) then error <= '1'; end if;
                    when 29 => if in_data /= stored_ip(23 downto 16) then error <= '1'; end if;
                    when 30 => if in_data /= stored_ip(15 downto 8)  then error <= '1'; end if;
                    when 31 => if in_data /= stored_ip(7 downto 0)   then error <= '1'; end if;
                    when others => null;
                end case;
            elsif current_state = IGNORE then
                error <= '0';
            end if;
        end if;
    end process;
    
    -- Output Control Signals
    out_valid <= '1' when current_state = ARP_REQUEST else '0';
    out_sop   <= '1' when current_state = ARP_REQUEST and byte_counter = 0 else '0';
    out_eop   <= '1' when current_state = ARP_REQUEST and byte_counter = ARP_PACKET_SIZE - 1 else '0';
    
    in_ready  <= '1' when current_state = RECEIVING_REPLY or current_state = IGNORE else '0';
    
    busy      <= '1' when current_state /= IDLE else '0';
    done      <= '1' when current_state = DONE_STATE else '0';
    
    -- MAC Address Output
    mac_address <= received_mac when current_state = DONE_STATE else (others => '0');
    
end Behavioral;